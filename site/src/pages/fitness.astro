---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getEntry } from 'astro:content';
import activitiesData from '../data/strava-activities.json';
import highlightRoutes from '../data/highlight-routes.json';
import milestonesData from '../data/milestones.json';

const page = await getEntry('pages', 'fitness');

// Process activities into a map of date -> activity data
const activityMap = new Map();
activitiesData.activities.forEach(activity => {
  const existing = activityMap.get(activity.date) || { count: 0, distance: 0, types: new Set(), activities: [] };
  existing.count += 1;
  existing.distance += activity.distance;
  existing.types.add(activity.type);
  existing.activities.push(activity.name);
  activityMap.set(activity.date, existing);
});

const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

// Function to generate calendar data for any year
function generateYearData(year: number) {
  const startDate = new Date(year, 0, 1);
  const endDate = new Date(year, 11, 31);

  // Find the first Sunday before or on Jan 1
  const firstSunday = new Date(startDate);
  firstSunday.setDate(firstSunday.getDate() - firstSunday.getDay());

  // Generate all weeks
  const weeks = [];
  let currentDate = new Date(firstSunday);

  while (currentDate <= endDate || weeks.length < 53) {
    const week = [];
    for (let i = 0; i < 7; i++) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const isCurrentYear = currentDate.getFullYear() === year;
      const activity = activityMap.get(dateStr);
      const isFuture = currentDate > new Date();

      week.push({
        date: dateStr,
        day: currentDate.getDate(),
        month: currentDate.getMonth(),
        isCurrentYear,
        isFuture,
        count: activity?.count || 0,
        distance: activity?.distance || 0,
        types: activity?.types ? Array.from(activity.types) : [],
        activities: activity?.activities || [],
      });
      currentDate.setDate(currentDate.getDate() + 1);
    }
    weeks.push(week);
    if (weeks.length >= 53) break;
  }

  // Calculate month label positions for this year
  const monthLabels = [];
  const labeledMonths = new Set();
  let weekIndex = 0;
  for (const week of weeks) {
    const firstDayOfWeek = week.find(d => d.isCurrentYear);
    if (firstDayOfWeek && firstDayOfWeek.day <= 7 && !labeledMonths.has(firstDayOfWeek.month)) {
      labeledMonths.add(firstDayOfWeek.month);
      monthLabels.push({
        month: months[firstDayOfWeek.month],
        left: weekIndex * 18,
      });
    }
    weekIndex++;
  }

  return { year, weeks, monthLabels };
}

// Generate data for multiple years (oldest first, scrolls forward in time)
const yearsToShow = [2022, 2023, 2024, 2025];
const yearDataList = yearsToShow.map(y => generateYearData(y));

// Process milestones - find position for each milestone's month
const processedMilestones = milestonesData.milestones.map(milestone => {
  const yearData = yearDataList.find(yd => yd.year === milestone.year);
  if (!yearData) return null;

  // Calculate exact position based on the 15th of the month
  // This avoids label positioning quirks
  const targetDate = new Date(milestone.year, milestone.month, 15);
  const targetDateStr = targetDate.toISOString().split('T')[0];
  
  // Find the week that contains the 15th (or closest)
  let weekIndex = yearData.weeks.findIndex(week => week.find(d => d.date === targetDateStr));
  
  // Fallback: if 15th not found (e.g. slight date mismatch), approximate with Start of Month + 2 weeks
  if (weekIndex === -1) {
      const firstDayOfMonth = new Date(milestone.year, milestone.month, 1).toISOString().split('T')[0];
      const startWeekIdx = yearData.weeks.findIndex(week => week.find(d => d.date === firstDayOfMonth));
      if (startWeekIdx !== -1) weekIndex = startWeekIdx + 2;
      else weekIndex = 0; // Should never happen
  }

  // Week width is 18px (14px cell + 4px gap). Center is +9px.
  const centerLeft = (weekIndex * 18) + 9;

  // Simple string hash for consistent randomness
  const hashString = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  };
  
  const rng = hashString(milestone.text + milestone.year);

  return {
    ...milestone,
    monthName: months[milestone.month],
    left: centerLeft,
    rng: rng,
    rotation: (rng % 16) - 8, // -8 to +8 degrees
    fontWeight: 400 + (rng % 3) * 100 // 400, 500, or 600
  };
}).filter(Boolean);

// Collision Detection & Tier Assignment
// We separate top and bottom milestones to handle them independently
const aboveMilestones = processedMilestones.filter(m => m.position === 'above').sort((a, b) => a.year - b.year || a.left - b.left);
const belowMilestones = processedMilestones.filter(m => m.position === 'below').sort((a, b) => a.year - b.year || a.left - b.left);

function assignTiers(milestones, defaultPadding = 20) {
  // Map<Year, Array<TierLastX>> - stores the right-most X coordinate for each tier in a year
  const yearTierEnds = new Map();
  
  milestones.forEach(m => {
    if (!yearTierEnds.has(m.year)) {
      yearTierEnds.set(m.year, []);
    }
    const tierEnds = yearTierEnds.get(m.year);
    
    // 1. Calculate precise width
    // Handle multiline text - take the longest line
    const lines = m.text.split('\n');
    const longestLine = lines.reduce((a, b) => a.length > b.length ? a : b, '');
    // Approx 9px per char (Caveat font is a bit wide) + padding
    const width = Math.max(longestLine.length * 9 + 16, 80);
    
    // 2. Calculate horizontal bounds [minX, maxX] relative to m.left anchor
    // Based on CSS transforms:
    // center: translateX(-50%) -> [left - w/2, left + w/2]
    // left: translateX(-10%)   -> [left - w*0.1, left + w*0.9]
    // right: translateX(-90%)  -> [left - w*0.9, left + w*0.1]
    
    const align = m.align || 'center';
    let minX, maxX;
    
    if (align === 'left') {
      minX = m.left - (width * 0.1);
      maxX = m.left + (width * 0.9);
    } else if (align === 'right') {
      minX = m.left - (width * 0.9);
      maxX = m.left + (width * 0.1);
    } else {
      minX = m.left - (width / 2);
      maxX = m.left + (width / 2);
    }
    
    // 3. Find the lowest tier that is free
    let assignedTier = 0;
    while (true) {
      // Get the right-most edge of the last item in this tier
      // Default to -Infinity so the first item always fits
      const lastEnd = tierEnds[assignedTier] !== undefined ? tierEnds[assignedTier] : -Infinity;
      
      // Check for overlap: does the current item start after the last one ends?
      if (minX > lastEnd + defaultPadding) {
        // Fits!
        break;
      }
      
      // Collision detected, try next tier
      assignedTier++;
    }
    
    m.tier = assignedTier;
    // Update this tier's end position
    tierEnds[assignedTier] = maxX;
  });
}

assignTiers(aboveMilestones);
assignTiers(belowMilestones);

// Combine back
const tierMap = new Map();
[...aboveMilestones, ...belowMilestones].forEach(m => {
  const key = `${m.year}-${m.month}-${m.text}`;
  tierMap.set(key, m);
});

// Helper to generate dynamic handwritten arrow path
function getArrowPath(tier, position, rng, align) {
  const isBelow = position === 'below';
  const baseHeight = 45;
  const tierStep = 35; 
  
  const totalHeight = baseHeight + (tier * tierStep);
  
  // Randomize controls slightly for natural look
  const r1 = (rng % 10) - 5;
  const r2 = ((rng >> 4) % 10) - 5;
  
  // Determine start X offset based on alignment
  // If text is align-left, it's shifted RIGHT, so arrow starts from +X.
  // We use exactly 60px to match the CSS transform
  let startX = 15; // Center of 30px box
  
  if (align === 'left') {
    startX += 60; 
  } else if (align === 'right') {
    startX -= 60;
  }
  
  // End X is always 15 (center relative to anchor)
  const endX = 15;

  // Use a Quadratic Curve (Q) for a smoother, simpler arc than the S-curve
  // Control point: weighted towards the start (text side) to create a "leaning" look?
  // Actually, standard midpoint Q is fine.
  
  const midX = (startX + endX) / 2;
  const bulge = (r1 * 2); 
  
  if (isBelow) {
    // Arrow pointing UP to heatmap
    // Start at text (startX, totalHeight) -> Tip at heatmap (endX, 4)
    return `M ${startX} ${totalHeight} Q ${midX + bulge} ${totalHeight * 0.5}, ${endX} 4`;
  } else {
    // Arrow pointing DOWN to heatmap
    // Start at text (startX, 2) -> Tip at heatmap (endX, totalHeight)
    return `M ${startX} 2 Q ${midX + bulge} ${totalHeight * 0.5}, ${endX} ${totalHeight}`;
  }
}

function getArrowHead(tier, position, rng, align) {
  const isBelow = position === 'below';
  const totalHeight = 45 + (tier * 35);
  let startX = 15;
  if (align === 'left') startX += 60;
  if (align === 'right') startX -= 60;
  
  const endX = 15;
  
  // Re-calculate control points to match getArrowPath exactly
  const r1 = (rng % 10) - 5;
  const midX = (startX + endX) / 2;
  const bulge = (r1 * 2);
  const cy = totalHeight * 0.5;
  const cx = midX + bulge;

  // Calculate tangent vector at the tip
  // For Quadratic Bezier B(t), tangent at t=1 is P2 - P1.
  let vx, vy;
  let tipX, tipY;

  if (isBelow) {
     // Path: Text (startX, totalHeight) -> P1(cx, cy) -> Heatmap (endX, 4)
     // Tip is at Heatmap (endX, 4)
     tipX = endX;
     tipY = 4;
     vx = tipX - cx;
     vy = tipY - cy;
  } else {
     // Path: Text (startX, 2) -> P1(cx, cy) -> Heatmap (endX, totalHeight)
     // Tip is at Heatmap (endX, totalHeight) - ALWAYS at center regardless of alignment
     tipX = endX;
     tipY = totalHeight;
     vx = tipX - cx;
     vy = tipY - cy;
  }
  
  // Normalize vector
  const len = Math.sqrt(vx*vx + vy*vy);
  const nx = vx / len;
  const ny = vy / len;
  
  // Perpendicular vector (-ny, nx)
  const px = -ny;
  const py = nx;
  
  // Arrow dimensions
  const length = 10;
  const width = 6;
  
  // Calculate wings
  // Wing1 = Tip - length*N + width*P
  // Wing2 = Tip - length*N - width*P
  
  const w1x = tipX - (length * nx) + (width * px);
  const w1y = tipY - (length * ny) + (width * py);
  
  const w2x = tipX - (length * nx) - (width * px);
  const w2y = tipY - (length * ny) - (width * py);
  
  // Draw simple V shape
  // Control point for subtle curve on the wings? Optional. 
  // Let's stick to simple lines for hand-drawn feel, maybe slightly curved.
  // M w1 Q (tip-len*0.5) tip  <-- gentle curve?
  // Let's do simple straight lines but with rounded join logic if needed. 
  // M w1 L tip L w2
  
  return `M ${w1x} ${w1y} L ${tipX} ${tipY} L ${w2x} ${w2y}`;
}

// Process year highlights (curly braces spanning full year)
const yearHighlights = (milestonesData.yearHighlights || []).map(highlight => {
  const yearData = yearDataList.find(yd => yd.year === highlight.year);
  if (!yearData) return null;

  // String hash for consistent randomness
  const hashString = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  };

  const rng = hashString(highlight.text + highlight.year);

  return {
    ...highlight,
    rng,
    rotation: ((rng % 6) - 3), // -3 to +3 degrees (subtle)
  };
}).filter(Boolean);

// Generate hand-drawn HORIZONTAL curly brace SVG path
// The brace spans the full width of the heatmap (~954px for 53 weeks)
function getHorizontalBracePath(width, rng) {
  const midX = width / 2;

  // Slight randomness for hand-drawn feel
  const r1 = ((rng % 3) - 1);
  const r2 = (((rng >> 3) % 3) - 1);

  // Proper curly brace shape with distinct cusp
  const topY = 3;            // Top edge where ends sit
  const cuspY = 22;          // Bottom of cusp (the pointed tip)
  const midCurveY = 16;      // Where curves meet the cusp arms
  const cuspArm = 12;        // Width of the V-shaped cusp

  // Build the path:
  // 1. Start at left end (0, topY)
  // 2. Curve down toward the left side of the cusp
  // 3. Sharp line down to the cusp point (center bottom)
  // 4. Sharp line up to the right side of the cusp
  // 5. Curve up to the right end (width, topY)

  const path = [
    `M 0 ${topY + r1}`,
    // Left curve: from left end, curving down to left arm of cusp
    `Q ${midX * 0.45} ${topY + 4 + r1}, ${midX - cuspArm} ${midCurveY}`,
    // Sharp down to cusp point
    `L ${midX} ${cuspY + r2}`,
    // Sharp up from cusp point
    `L ${midX + cuspArm} ${midCurveY}`,
    // Right curve: from right arm of cusp, curving up to right end
    `Q ${midX * 1.55} ${topY + 4 - r1}, ${width} ${topY - r2}`
  ];

  return path.join(' ');
}

---

<BaseLayout title={page.data.title} description={page.data.description}>
  <div class="fitness-page">
    <h1>{page.data.title}</h1>

    <div class="distance-journey">
      <div class="journey-content">
        <svg class="journey-path" viewBox="0 0 1000 180">
          <!-- Running path -->
          <path
            d="M 80 70 Q 500 10 920 70"
            fill="none"
            stroke="#fc4c02"
            stroke-width="2.5"
            stroke-dasharray="6 10"
            stroke-linecap="round"
          />
          <!-- Runner icon -->
          <g transform="translate(48, 43) scale(0.14)" fill="#fc4c02">
            <path d="M120,56a32,32,0,1,1,32,32A32,32,0,0,1,120,56Zm103.28,74.08a8,8,0,0,0-10.6-4c-.25.12-26.71,10.72-72.18-20.19-52.29-35.54-88-7.77-89.51-6.57a8,8,0,1,0,10,12.48c.26-.21,25.12-19.5,64.07,3.27-4.25,13.35-12.76,31.82-25.25,47-18.56,22.48-41.11,32.56-67,30A8,8,0,0,0,31.2,208a92.29,92.29,0,0,0,9.34.47c27.38,0,52-12.38,71.63-36.18.57-.69,1.14-1.4,1.69-2.1C133.31,175.29,168,190.3,168,232a8,8,0,0,0,16,0c0-24.65-10.08-45.35-29.15-59.86a104.29,104.29,0,0,0-31.31-15.81A169.31,169.31,0,0,0,139,124c26.14,16.09,46.84,20,60.69,20,12.18,0,19.06-3,19.67-3.28A8,8,0,0,0,223.28,130.08Z"/>
          </g>
          <!-- Running distance text -->
          <g transform="translate(920, 70) rotate(8)">
            <text x="10" y="-6" class="journey-distance">2,181</text>
            <text x="10" y="10" class="journey-unit">kms of running</text>
          </g>

          <!-- Cycling path -->
          <path
            d="M 80 140 Q 500 80 920 140"
            fill="none"
            stroke="#fc4c02"
            stroke-width="2.5"
            stroke-dasharray="6 10"
            stroke-linecap="round"
          />
          <!-- Cyclist icon -->
          <g transform="translate(45, 108) scale(0.14)" fill="#fc4c02">
            <path d="M54.46,164.71,82.33,126.5a48,48,0,1,1-12.92-9.44L41.54,155.29a8,8,0,1,0,12.92,9.42ZM208,112a47.81,47.81,0,0,0-16.93,3.09L214.91,156A8,8,0,1,1,201.09,164l-23.83-40.86A48,48,0,1,0,208,112ZM165.93,72H192a8,8,0,0,1,8,8,8,8,0,0,0,16,0,24,24,0,0,0-24-24H152a8,8,0,0,0-6.91,12l11.65,20H99.26L82.91,60A8,8,0,0,0,76,56H48a8,8,0,0,0,0,16H71.41L85.12,95.51,69.41,117.06a47.87,47.87,0,0,1,12.92,9.44l11.59-15.9L125.09,164A8,8,0,1,0,138.91,156l-30.32-52h57.48l11.19,19.17a48.11,48.11,0,0,1,13.81-8.08Z"/>
          </g>
          <!-- Cycling distance text -->
          <g transform="translate(920, 140) rotate(8)">
            <text x="10" y="-6" class="journey-distance">6,295</text>
            <text x="10" y="10" class="journey-unit">kms of cycling</text>
          </g>
        </svg>
      </div>
    </div>

    <div class="highlight-section">
      <h2>Places we go</h2>

      {highlightRoutes.highlights.map((highlight) => (
        <div class="route-highlight-wrapper">
          <div class="route-header">
            <span class="activity-icon">
              {highlight.type === 'Hike' && (
                <svg viewBox="0 0 256 256" fill="currentColor">
                  <path d="M120,48a32,32,0,1,1,32,32A32,32,0,0,1,120,48Zm72,88c-23.37,0-28.92-8.56-36.6-20.4-3.65-5.64-7.79-12-14.16-17.55a40.92,40.92,0,0,0-8-5.47,8,8,0,0,0-11,3.92L64.66,228.81a8,8,0,0,0,4.15,10.52A7.84,7.84,0,0,0,72,240a8,8,0,0,0,7.34-4.81l33.59-77.27L144,180.12V232a8,8,0,0,0,16,0V176a8,8,0,0,0-3.35-6.51l-37.2-26.57,13.4-30.81c3.57,3.62,6.28,7.8,9.13,12.19,7.67,11.84,16.27,25.11,42,27.36V232a8,8,0,0,0,16,0V144A8,8,0,0,0,192,136ZM72,152a8,8,0,0,0,7.36-4.85l24-56a8,8,0,0,0-4.2-10.5l-28-12a8,8,0,0,0-10.5,4.2l-24,56a8,8,0,0,0,4.2,10.5l28,12A8,8,0,0,0,72,152Z"/>
                </svg>
              )}
              {highlight.type === 'Run' && (
                <svg viewBox="0 0 256 256" fill="currentColor">
                  <path d="M120,56a32,32,0,1,1,32,32A32,32,0,0,1,120,56Zm103.28,74.08a8,8,0,0,0-10.6-4c-.25.12-26.71,10.72-72.18-20.19-52.29-35.54-88-7.77-89.51-6.57a8,8,0,1,0,10,12.48c.26-.21,25.12-19.5,64.07,3.27-4.25,13.35-12.76,31.82-25.25,47-18.56,22.48-41.11,32.56-67,30A8,8,0,0,0,31.2,208a92.29,92.29,0,0,0,9.34.47c27.38,0,52-12.38,71.63-36.18.57-.69,1.14-1.4,1.69-2.1C133.31,175.29,168,190.3,168,232a8,8,0,0,0,16,0c0-24.65-10.08-45.35-29.15-59.86a104.29,104.29,0,0,0-31.31-15.81A169.31,169.31,0,0,0,139,124c26.14,16.09,46.84,20,60.69,20,12.18,0,19.06-3,19.67-3.28A8,8,0,0,0,223.28,130.08Z"/>
                </svg>
              )}
              {highlight.type === 'Walk' && (
                <svg viewBox="0 0 256 256" fill="currentColor">
                  <path d="M120,48a32,32,0,1,1,32,32A32,32,0,0,1,120,48Zm88,88c-28.64,0-41.81-13.3-55.75-27.37-3.53-3.57-7.18-7.26-11-10.58-37-32.14-96.22,22.73-98.72,25.08a8,8,0,0,0,10.95,11.66A163.88,163.88,0,0,1,84,113c13.78-7.38,25.39-10.23,34.7-8.58L64.66,228.81a8,8,0,0,0,4.15,10.52A7.84,7.84,0,0,0,72,240a8,8,0,0,0,7.34-4.81l33.59-77.27L144,180.12V232a8,8,0,0,0,16,0V176a8,8,0,0,0-3.35-6.51l-37.2-26.57L132.88,112c2.64,2.44,5.26,5.07,8,7.84C155.05,134.19,172.69,152,208,152a8,8,0,0,0,0-16Z"/>
                </svg>
              )}
              {highlight.type === 'Ride' && (
                <svg viewBox="0 0 256 256" fill="currentColor">
                  <path d="M54.46,164.71,82.33,126.5a48,48,0,1,1-12.92-9.44L41.54,155.29a8,8,0,1,0,12.92,9.42ZM208,112a47.81,47.81,0,0,0-16.93,3.09L214.91,156A8,8,0,1,1,201.09,164l-23.83-40.86A48,48,0,1,0,208,112ZM165.93,72H192a8,8,0,0,1,8,8,8,8,0,0,0,16,0,24,24,0,0,0-24-24H152a8,8,0,0,0-6.91,12l11.65,20H99.26L82.91,60A8,8,0,0,0,76,56H48a8,8,0,0,0,0,16H71.41L85.12,95.51,69.41,117.06a47.87,47.87,0,0,1,12.92,9.44l11.59-15.9L125.09,164A8,8,0,1,0,138.91,156l-30.32-52h57.48l11.19,19.17a48.11,48.11,0,0,1,13.81-8.08Z"/>
                </svg>
              )}
              {highlight.type === 'Workout' && (
                <svg viewBox="0 0 256 256" fill="currentColor">
                  <path d="M200,64V192a16,16,0,0,1-16,16H168a16,16,0,0,1-16-16V136H104v56a16,16,0,0,1-16,16H72a16,16,0,0,1-16-16V64A16,16,0,0,1,72,48H88a16,16,0,0,1,16,16v56h48V64a16,16,0,0,1,16-16h16A16,16,0,0,1,200,64ZM36,72H32A16,16,0,0,0,16,88v32H8.27A8.18,8.18,0,0,0,0,127.47,8,8,0,0,0,8,136h8v32a16,16,0,0,0,16,16h4a4,4,0,0,0,4-4V76A4,4,0,0,0,36,72Zm220,55.47a8.18,8.18,0,0,0-8.25-7.47H240V88a16,16,0,0,0-16-16h-4a4,4,0,0,0-4,4V180a4,4,0,0,0,4,4h4a16,16,0,0,0,16-16V136h8A8,8,0,0,0,256,127.47Z"/>
                </svg>
              )}
            </span>
            <div class="route-header-text">
              <span class="route-title">{highlight.name}</span>
              <span class="route-tagline">{highlight.tagline}</span>
            </div>
            <div class="date-sticker">
              <span class="date-month">{new Date(highlight.date).toLocaleDateString('en-US', { month: 'short' })}</span>
              <span class="date-year">{new Date(highlight.date).getFullYear()}</span>
            </div>
          </div>
          <div class="route-card">
            <div
              class="route-map"
              id={`map-${highlight.id}`}
              data-center={JSON.stringify(highlight.center)}
              data-zoom={highlight.zoom}
              data-route={JSON.stringify(highlight.route)}
              data-start-time={highlight.startTime}
              data-photos={JSON.stringify(highlight.photos || [])}
            ></div>
            <div class="start-time-flash" id={`flash-${highlight.id}`}>
              <span class="flash-time">{highlight.startTime}</span>
            </div>
            <div class="photo-slideshow" id={`slideshow-${highlight.id}`}></div>
            <div class="route-overlay">
              <div class="route-meta">
                <span>{highlight.location}</span>
                <span class="meta-stat">
                  <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
                    <path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 10H3V8h2v4h2V8h2v4h2V8h2v4h2V8h2v4h2V8h2v8z"/>
                  </svg>
                  {highlight.distance} km
                </span>
                <span class="meta-stat">
                  <svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14">
                    <path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
                  </svg>
                  {highlight.duration}
                </span>
              </div>
              <a href={highlight.stravaUrl} target="_blank" rel="noopener noreferrer" class="strava-link" title="View on Strava">
                <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                  <path d="M15.387 17.944l-2.089-4.116h-3.065L15.387 24l5.15-10.172h-3.066m-7.008-5.599l2.836 5.598h4.172L10.463 0l-7 13.828h4.169"/>
                </svg>
              </a>
            </div>
          </div>
        </div>
      ))}
    </div>

    <div class="timeline-section">
      <h2>We Keep Movin'</h2>
      <div class="timeline-scroll-container">
        <div class="timeline-track">
          {/* First set of years */}
          {yearDataList.map((yearData) => {
            const yearMilestones = processedMilestones.filter(m => m.year === yearData.year);
            return (
              <div class="year-heatmap">
                <div class="year-label">{yearData.year}</div>
                <div class="heatmap-container">
                  <div class="heatmap-days">
                    {days.map((day, i) => (
                      <div class="day-label" style={i % 2 === 0 ? '' : 'visibility: hidden'}>{day}</div>
                    ))}
                  </div>
                  <div class="heatmap-wrapper">
                    <div class="heatmap-months">
                      {yearData.monthLabels.map((label) => (
                        <div class="month-label" style={`left: ${label.left}px`}>{label.month}</div>
                      ))}
                    </div>
                    <div class="heatmap-grid">
                      {yearData.weeks.map((week) => (
                        <div class="heatmap-week">
                          {week.map((day) => {
                            const level = day.count === 0 ? 0 : day.count === 1 ? 1 : day.count === 2 ? 2 : 3;
                            const classes = ['heatmap-cell', `level-${level}`];
                            if (!day.isCurrentYear) classes.push('outside');
                            if (day.isFuture) classes.push('future');
                            return <div class={classes.join(' ')} />;
                          })}
                        </div>
                      ))}
                    </div>
                    {/* Milestone annotations */}
                    {yearMilestones.map((originalMilestone, idx) => {
                      // Lookup processed version with tier info
                      const key = `${originalMilestone.year}-${originalMilestone.month}-${originalMilestone.text}`;
                      const milestone = tierMap.get(key) || originalMilestone;
                      
                      const isBelow = milestone.position === 'below';
                      const align = milestone.align || 'center';
                      const hasNewline = milestone.text.includes('\n');
                      const tier = milestone.tier || 0;
                      
                      const verticalOffset = tier * 35;
                      const arrowHeight = 45 + (tier * 35);
                      const arrowPath = getArrowPath(tier, milestone.position, milestone.rng || 0, align);
                      const arrowHead = getArrowHead(tier, milestone.position, milestone.rng || 0, align);

                      return (
                        <div
                          class={`milestone-annotation ${isBelow ? 'below' : 'above'} align-${align}`}
                          style={`
                            left: ${milestone.left}px;
                            --tier-offset: ${verticalOffset}px;
                            --rotation: ${milestone.rotation || 0}deg;
                            --font-weight: ${milestone.fontWeight || 400};
                            z-index: ${10 + tier};
                          `}
                        >
                          {!isBelow && <div class={`milestone-text ${hasNewline ? 'multiline' : ''}`}>{milestone.text}</div>}
                          <svg 
                            class="milestone-arrow" 
                            style={`height: ${arrowHeight}px; width: 30px;`}
                            viewBox={`0 0 30 ${arrowHeight}`}
                            fill="none" 
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d={arrowPath}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              fill="none"
                            />
                            <path
                              d={arrowHead}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              fill="none"
                            />
                          </svg>
                          {isBelow && <div class={`milestone-text ${hasNewline ? 'multiline' : ''}`}>{milestone.text}</div>}
                        </div>
                      );
                    })}
                    {/* Year highlight - horizontal curly brace spanning full year */}
                    {yearHighlights.filter(h => h.year === yearData.year).map((highlight) => {
                      const braceWidth = yearData.weeks.length * 18; // Width of heatmap grid (weeks × 18px)
                      const braceHeight = 28; // Height of SVG (enough for the cusp)
                      const bracePath = getHorizontalBracePath(braceWidth, highlight.rng);

                      return (
                        <div class="year-highlight-brace">
                          <svg
                            class="curly-brace-horizontal"
                            viewBox={`0 0 ${braceWidth} ${braceHeight}`}
                            fill="none"
                            xmlns="http://www.w3.org/2000/svg"
                            style={`width: ${braceWidth}px;`}
                          >
                            <path
                              d={bracePath}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              stroke-linejoin="round"
                              fill="none"
                            />
                          </svg>
                          <div
                            class="year-highlight-text"
                            style={`--rotation: ${highlight.rotation}deg;`}
                          >
                            {highlight.text}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            );
          })}
          {/* Duplicate set for seamless infinite scroll */}
          {yearDataList.map((yearData) => {
            const yearMilestones = processedMilestones.filter(m => m.year === yearData.year);
            return (
              <div class="year-heatmap" aria-hidden="true">
                <div class="year-label">{yearData.year}</div>
                <div class="heatmap-container">
                  <div class="heatmap-days">
                    {days.map((day, i) => (
                      <div class="day-label" style={i % 2 === 0 ? '' : 'visibility: hidden'}>{day}</div>
                    ))}
                  </div>
                  <div class="heatmap-wrapper">
                    <div class="heatmap-months">
                      {yearData.monthLabels.map((label) => (
                        <div class="month-label" style={`left: ${label.left}px`}>{label.month}</div>
                      ))}
                    </div>
                    <div class="heatmap-grid">
                      {yearData.weeks.map((week) => (
                        <div class="heatmap-week">
                          {week.map((day) => {
                            const level = day.count === 0 ? 0 : day.count === 1 ? 1 : day.count === 2 ? 2 : 3;
                            const classes = ['heatmap-cell', `level-${level}`];
                            if (!day.isCurrentYear) classes.push('outside');
                            if (day.isFuture) classes.push('future');
                            return <div class={classes.join(' ')} />;
                          })}
                        </div>
                      ))}
                    </div>
                    {/* Milestone annotations */}
                    {yearMilestones.map((originalMilestone, idx) => {
                      // Lookup processed version with tier info
                      const key = `${originalMilestone.year}-${originalMilestone.month}-${originalMilestone.text}`;
                      const milestone = tierMap.get(key) || originalMilestone;
                      
                      const isBelow = milestone.position === 'below';
                      const align = milestone.align || 'center';
                      const hasNewline = milestone.text.includes('\n');
                      const tier = milestone.tier || 0;
                      
                      const verticalOffset = tier * 35;
                      const arrowHeight = 45 + (tier * 35);
                      const arrowPath = getArrowPath(tier, milestone.position, milestone.rng || 0, align);
                      const arrowHead = getArrowHead(tier, milestone.position, milestone.rng || 0, align);

                      return (
                        <div
                          class={`milestone-annotation ${isBelow ? 'below' : 'above'} align-${align}`}
                          style={`
                            left: ${milestone.left}px;
                            --tier-offset: ${verticalOffset}px;
                            --rotation: ${milestone.rotation || 0}deg;
                            --font-weight: ${milestone.fontWeight || 400};
                            z-index: ${10 + tier};
                          `}
                        >
                          {!isBelow && <div class={`milestone-text ${hasNewline ? 'multiline' : ''}`}>{milestone.text}</div>}
                          <svg 
                            class="milestone-arrow" 
                            style={`height: ${arrowHeight}px; width: 30px;`}
                            viewBox={`0 0 30 ${arrowHeight}`}
                            fill="none" 
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d={arrowPath}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              fill="none"
                            />
                            <path
                              d={arrowHead}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              fill="none"
                            />
                          </svg>
                          {isBelow && <div class={`milestone-text ${hasNewline ? 'multiline' : ''}`}>{milestone.text}</div>}
                        </div>
                      );
                    })}
                    {/* Year highlight - horizontal curly brace (duplicate for infinite scroll) */}
                    {yearHighlights.filter(h => h.year === yearData.year).map((highlight) => {
                      const braceWidth = yearData.weeks.length * 18;
                      const braceHeight = 28;
                      const bracePath = getHorizontalBracePath(braceWidth, highlight.rng);

                      return (
                        <div class="year-highlight-brace">
                          <svg
                            class="curly-brace-horizontal"
                            viewBox={`0 0 ${braceWidth} ${braceHeight}`}
                            fill="none"
                            xmlns="http://www.w3.org/2000/svg"
                            style={`width: ${braceWidth}px;`}
                          >
                            <path
                              d={bracePath}
                              stroke="#fc4c02"
                              stroke-width="1.5"
                              stroke-linecap="round"
                              stroke-linejoin="round"
                              fill="none"
                            />
                          </svg>
                          <div
                            class="year-highlight-text"
                            style={`--rotation: ${highlight.rotation}deg;`}
                          >
                            {highlight.text}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>

  </div>
</BaseLayout>

<style>
  .fitness-page {
    max-width: var(--content-width);
    margin: 0 auto;
  }

  .fitness-page h1 {
    margin-top: 0;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .heatmap-section {
    margin: 2.5rem 0;
  }

  .heatmap-section h2 {
    font-size: 1.2rem;
    margin-bottom: 1rem;
  }

  .heatmap-container {
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    padding-bottom: 0.5rem;
  }

  .heatmap-days {
    display: flex;
    flex-direction: column;
    gap: 3px;
    padding-top: 20px;
  }

  .day-label {
    font-size: 0.65rem;
    color: var(--color-text-light);
    height: 12px;
    line-height: 12px;
  }

  .heatmap-wrapper {
    position: relative;
    flex: 1;
  }

  .heatmap-months {
    position: relative;
    height: 20px;
    margin-bottom: 0.5rem;
  }

  .month-label {
    position: absolute;
    font-size: 0.65rem;
    color: var(--color-text-light);
  }

  .heatmap-grid {
    display: flex;
    gap: 3px;
  }

  .heatmap-week {
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .heatmap-cell {
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }

  .heatmap-cell.outside {
    visibility: hidden;
  }

  .heatmap-cell.future {
    background: var(--color-bg);
    border: 1px dashed var(--color-border);
  }

  /* Strava-style orange color palette */
  .level-0 {
    background: #ebedf0;
  }

  .level-1 {
    background: #fdcfb8;
  }

  .level-2 {
    background: #fc8c5a;
  }

  .level-3 {
    background: #fc4c02;
  }

  /* Dark mode support - Strava orange */
  @media (prefers-color-scheme: dark) {
    .level-0 {
      background: #161b22;
    }
    .level-1 {
      background: #4a2a18;
    }
    .level-2 {
      background: #8c3d12;
    }
    .level-3 {
      background: #fc4c02;
    }
  }

  /* Distance Journey Visualization */
  .distance-journey {
    position: relative;
    margin: 3rem 0 4rem;
    margin-left: calc(-50vw + 50%);
    margin-right: calc(-50vw + 50%);
    width: 100vw;
    padding: 0 1rem;
    box-sizing: border-box;
  }

  .journey-content {
    max-width: 1200px;
    margin: 0 auto;
  }

  .journey-path {
    width: 100%;
    height: auto;
    display: block;
    overflow: visible;
  }

  .journey-distance {
    font-family: inherit;
    font-size: 24px;
    font-weight: 400;
    fill: #fc4c02;
  }

  .journey-unit {
    font-family: inherit;
    font-size: 10px;
    font-weight: 400;
    fill: #fc4c02;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  @media (max-width: 600px) {
    .distance-journey {
      margin: 2rem 0 3rem;
      padding: 0 0.5rem;
    }

    .journey-distance {
      font-size: 18px;
    }

    .journey-unit {
      font-size: 7px;
    }
  }

  /* Route Highlights - Hall of Fame style */
  .highlight-section {
    margin: 4rem 0;
    /* Break out of container for full-width feel */
    margin-left: calc(-50vw + 50%);
    margin-right: calc(-50vw + 50%);
    padding: 0 5vw;
  }

  .highlight-section h2 {
    font-size: 1.4rem;
    margin-bottom: 2.5rem;
    text-align: center;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    color: var(--color-text-light);
  }

  .route-highlight-wrapper {
    max-width: 700px;
    margin-bottom: 4rem;
    position: relative;
  }

  /* Alternating left-right layout - gentle offset */
  .route-highlight-wrapper:nth-child(odd) {
    margin-left: 15%;
    margin-right: auto;
  }

  .route-highlight-wrapper:nth-child(even) {
    margin-left: auto;
    margin-right: 15%;
  }

  .route-header {
    display: flex;
    align-items: flex-start;
    gap: 0.6rem;
    margin-bottom: 0.75rem;
    padding-left: 0.25rem;
  }

  .activity-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fc4c02;
  }

  .activity-icon svg {
    width: 42px;
    height: 42px;
  }

  .route-header-text {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
  }

  .route-title {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--color-text);
    letter-spacing: -0.01em;
  }

  .route-tagline {
    font-size: 0.9rem;
    color: var(--color-text-light);
    font-style: italic;
  }

  .date-sticker {
    position: absolute;
    top: 80px;
    left: -40px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 58px;
    height: 58px;
    background: #fc4c02;
    color: white;
    border-radius: 50%;
    transform: rotate(-12deg);
    box-shadow: 0 4px 16px rgba(252, 76, 2, 0.4);
    z-index: 10;
  }

  /* Odd cards (displayed on right side of page): sticker on left of card */
  .route-highlight-wrapper:nth-child(odd) .date-sticker {
    left: -40px;
    right: auto;
    transform: rotate(-12deg);
  }

  /* Even cards (displayed on left side of page): sticker on right of card */
  .route-highlight-wrapper:nth-child(even) .date-sticker {
    left: auto;
    right: -40px;
    transform: rotate(12deg);
  }

  .date-month {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.02em;
    line-height: 1;
  }

  .date-year {
    font-size: 0.65rem;
    font-weight: 500;
    opacity: 0.9;
    line-height: 1.2;
  }

  .route-card {
    position: relative;
    border-radius: 20px;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease, overflow 0s;
  }

  .route-card.photo-focused {
    overflow: visible;
  }

  .route-card:hover {
    transform: translateY(-4px) scale(1.01);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  }

  .route-map {
    height: 450px;
    width: 100%;
    background: #1a1a1a;
  }

  @media (max-width: 900px) {
    .highlight-section {
      padding: 0 1rem;
    }

    .route-highlight-wrapper {
      max-width: 100%;
      margin-left: 0 !important;
      margin-right: 0 !important;
    }

    .date-sticker {
      top: 60px;
      left: auto;
      right: -10px;
      width: 50px;
      height: 50px;
    }

    .route-highlight-wrapper:nth-child(odd) .date-sticker,
    .route-highlight-wrapper:nth-child(even) .date-sticker {
      left: auto;
      right: -10px;
      transform: rotate(10deg);
    }

    .route-map {
      height: 380px;
    }

    /* Ensure focused photos don't cause horizontal scroll */
    .route-card.photo-focused {
      overflow: visible;
    }

    .highlight-section {
      overflow-x: clip;
    }
  }

  .route-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1.5rem 1.25rem 1rem;
    background: linear-gradient(to top, rgba(0,0,0,0.75) 0%, rgba(0,0,0,0.3) 70%, transparent 100%);
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    z-index: 1000;
  }

  /* Ensure Leaflet doesn't create a new stacking context that hides our overlays */
  :global(.route-map .leaflet-pane),
  :global(.route-map .leaflet-control-container) {
    z-index: auto !important;
  }

  .route-meta {
    display: flex;
    gap: 0.5rem;
    font-size: 0.85rem;
    color: rgba(255,255,255,0.9);
    flex-wrap: wrap;
    pointer-events: none;
  }

  .route-meta span {
    display: flex;
    align-items: center;
  }

  .route-meta .meta-stat {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
  }

  .route-meta .meta-stat svg {
    opacity: 0.85;
    flex-shrink: 0;
  }

  .route-meta span:not(:last-child)::after {
    content: "·";
    margin-left: 0.5rem;
    opacity: 0.5;
  }

  .strava-link {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: #fc4c02;
    color: white;
    border-radius: 50%;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 2px 8px rgba(252, 76, 2, 0.4);
  }

  .strava-link:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 16px rgba(252, 76, 2, 0.6);
  }

  .strava-link svg {
    width: 18px;
    height: 18px;
  }

  /* Vignette effect */
  .route-card::before {
    content: '';
    position: absolute;
    inset: 0;
    box-shadow: inset 0 0 80px 20px rgba(0, 0, 0, 0.3);
    pointer-events: none;
    z-index: 1;
    border-radius: 16px;
  }

  /* Start time flash */
  .start-time-flash {
    position: absolute;
    top: 1.25rem;
    left: 1.25rem;
    z-index: 1001;
    opacity: 0;
    pointer-events: none;
  }

  .start-time-flash.animate {
    animation: flashIn 3s ease-out forwards;
  }

  .flash-time {
    font-size: 1.1rem;
    font-weight: 600;
    color: rgba(255,255,255,0.9);
    text-shadow: 0 2px 8px rgba(0,0,0,0.6);
    letter-spacing: 0.02em;
  }

  @keyframes flashIn {
    0% {
      opacity: 0;
    }
    10% {
      opacity: 1;
    }
    75% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  /* Photo slideshow - polaroid stickers */
  .photo-slideshow {
    position: absolute;
    inset: 0;
    z-index: 500;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Hide Leaflet controls for cleaner look */
  :global(.route-map .leaflet-control-zoom) {
    display: none;
  }

  :global(.route-map .leaflet-control-attribution) {
    font-size: 9px;
    background: rgba(0,0,0,0.5) !important;
    color: rgba(255,255,255,0.5) !important;
    padding: 2px 6px;
    border-radius: 4px 0 0 0;
  }

  :global(.route-map .leaflet-control-attribution a) {
    color: rgba(255,255,255,0.6) !important;
  }

  /* Animated route marker - must be global for Leaflet */
  :global(.route-marker) {
    background: transparent !important;
    border: none !important;
  }

  :global(.route-arrow) {
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-bottom: 14px solid #fc4c02;
    filter: drop-shadow(0 0 4px rgba(252, 76, 2, 0.8)) drop-shadow(0 0 8px rgba(252, 76, 2, 0.5));
    transition: transform 0.15s ease-out;
  }

  :global(.route-marker-wrapper) {
    transition: transform 0.12s linear;
  }

  /* Smooth marker movement on map */
  :global(.route-marker) {
    transition: transform 0.1s linear !important;
  }

  /* Timeline Section - Multi-year horizontal scrolling heatmap */
  .timeline-section {
    margin: 4rem 0 2rem;
    padding-top: 3rem;
    border-top: 1px solid var(--color-border);
    /* Break out of container for full-width feel */
    margin-left: calc(-50vw + 50%);
    margin-right: calc(-50vw + 50%);
    width: 100vw;
    background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.02) 50%, transparent 100%);
  }

  .timeline-section h2 {
    font-size: 1.4rem;
    margin-bottom: 2rem;
    text-align: center;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--color-text-light);
  }

  .timeline-scroll-container {
    overflow-x: auto;
    overflow-y: visible;
    position: relative;
    padding: 1rem 0 2rem;
    /* Hide scrollbar but keep functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
    cursor: grab;
  }

  .timeline-scroll-container::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
  }

  .timeline-scroll-container:active {
    cursor: grabbing;
  }

  .timeline-track {
    display: flex;
    gap: 4rem;
    width: max-content;
    padding: 0 2rem;
    overflow: visible;
  }

  .year-heatmap {
    flex-shrink: 0;
    padding: 4rem 0 10rem; /* Extra space: 4rem top for annotations, 10rem bottom for year highlight brace */
    overflow: visible;
  }

  .year-label {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: 1rem;
    text-align: center;
    letter-spacing: 0.02em;
  }

  .year-heatmap .heatmap-container {
    overflow: visible;
  }

  .year-heatmap .heatmap-cell {
    width: 14px;
    height: 14px;
  }

  .year-heatmap .heatmap-week {
    gap: 4px;
  }

  .year-heatmap .heatmap-grid {
    gap: 4px;
  }

  .year-heatmap .heatmap-days {
    gap: 4px;
    padding-top: 22px;
  }

  .year-heatmap .day-label {
    height: 14px;
    line-height: 14px;
  }

  @media (prefers-color-scheme: dark) {
    .timeline-section {
      background: linear-gradient(180deg, transparent 0%, rgba(255,255,255,0.02) 50%, transparent 100%);
    }
  }

  @media (max-width: 600px) {
    .timeline-track {
      gap: 3rem;
      padding: 0 1rem;
    }

    .year-label {
      font-size: 1.1rem;
    }

    .year-heatmap .heatmap-cell {
      width: 10px;
      height: 10px;
    }

    .year-heatmap .heatmap-week,
    .year-heatmap .heatmap-grid {
      gap: 2px;
    }

    .year-heatmap .heatmap-days {
      gap: 2px;
      padding-top: 18px;
    }

    .year-heatmap .day-label {
      height: 10px;
      line-height: 10px;
      font-size: 0.55rem;
    }
  }

  /* Milestone annotations - hand-drawn style */
  .heatmap-wrapper {
    overflow: visible;
  }

  .heatmap-container {
    overflow: visible;
  }

  .milestone-annotation {
    position: absolute;
    /* Center the container on the anchor point */
    transform: translateX(-50%); 
    display: flex;
    flex-direction: column;
    align-items: center;
    pointer-events: none;
    z-index: 10;
    /* Ensure width doesn't collapse too much */
    min-width: 100px; 
  }

  /* Fixed positioning relative to the Heatmap Grid (Height ~116px) */
  .milestone-annotation.above {
    top: auto;
    /* Sit just above the grid (height 116px + small buffer) */
    bottom: 118px; 
  }

  .milestone-annotation.below {
    bottom: auto;
    /* Sit just below the wrapper */
    top: 100%; 
    margin-top: -10px; /* Pull up closer to grid */
  }

  .milestone-text {
    font-family: 'Caveat', cursive;
    font-size: 1.15rem;
    font-weight: var(--font-weight, 500);
    color: #fc4c02;
    white-space: nowrap;
    text-align: center;
    line-height: 1.1;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    transform: rotate(var(--rotation, 0deg));
    transition: transform 0.2s;
  }

  /* Shift text relative to arrow without moving arrow */
  /* We use fixed pixels to match the SVG arrow generation logic strictly */
  .milestone-annotation.align-left .milestone-text {
    transform: translateX(60px) rotate(var(--rotation, 0deg));
  }

  .milestone-annotation.align-right .milestone-text {
    transform: translateX(-60px) rotate(var(--rotation, 0deg));
  }

  .milestone-annotation .milestone-text.multiline {
    white-space: pre-line;
  }

  /* Adjust positioning for multiline text - relative to the dynamic bottom/top */
  .milestone-annotation.above:has(.multiline) {
    margin-bottom: 8px; /* Reduced margin */
  }

  .milestone-annotation.below:has(.multiline) {
    margin-top: 8px;
  }

  .milestone-arrow {
    width: 30px;
    height: auto; /* Dynamic height */
    overflow: visible;
    flex-shrink: 0; /* Prevent squishing */
  }
  
  /* Ensure SVG is centered in the flexible container */
  .milestone-annotation svg {
     display: block;
  }

  /* Year highlight - horizontal curly brace spanning full year */
  .year-highlight-brace {
    position: absolute;
    left: 0;
    top: 100%;
    /* Position well below heatmap, clearing any "below" milestone annotations */
    margin-top: 95px;
    display: flex;
    flex-direction: column;
    align-items: center;
    pointer-events: none;
    z-index: 5;
  }

  .curly-brace-horizontal {
    height: 28px;
    flex-shrink: 0;
  }

  .year-highlight-text {
    font-family: 'Caveat', cursive;
    font-size: 1.2rem;
    font-weight: 500;
    color: #fc4c02;
    white-space: nowrap;
    line-height: 1.2;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    text-align: center;
    margin-top: 4px;
    /* Slight hand-drawn tilt */
    transform: rotate(var(--rotation, 0deg));
  }

  /* Mobile adjustments for year highlight */
  @media (max-width: 600px) {
    .year-highlight-brace {
      margin-top: 75px;
    }

    .curly-brace-horizontal {
      height: 26px;
    }

    .year-highlight-text {
      font-size: 1rem;
    }
  }
</style>

<script is:inline>
  // Dynamically load Leaflet CSS
  var leafletCSS = document.createElement('link');
  leafletCSS.rel = 'stylesheet';
  leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
  document.head.appendChild(leafletCSS);

  // Load Caveat font for milestone annotations
  var caveatFont = document.createElement('link');
  caveatFont.rel = 'stylesheet';
  caveatFont.href = 'https://fonts.googleapis.com/css2?family=Caveat:wght@500&display=swap';
  document.head.appendChild(caveatFont);
</script>
<script is:inline src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script is:inline>
  document.addEventListener('DOMContentLoaded', function() {
    var mapContainers = document.querySelectorAll('.route-map');

    mapContainers.forEach(function(container) {
      var center = JSON.parse(container.dataset.center);
      var zoom = parseInt(container.dataset.zoom, 10);
      var route = JSON.parse(container.dataset.route);
      var photos = JSON.parse(container.dataset.photos || '[]');
      var mapId = container.id;
      var flashId = mapId.replace('map-', 'flash-');
      var slideshowId = mapId.replace('map-', 'slideshow-');
      var flashElement = document.getElementById(flashId);
      var slideshowElement = document.getElementById(slideshowId);
      var routeCard = container.closest('.route-card');

      var map = L.map(container.id, {
        scrollWheelZoom: false,
      }).setView(center, zoom);

      // Use OpenTopoMap for earthy terrain aesthetic - perfect for hiking
      L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
        maxZoom: 17,
        subdomains: 'abc',
      }).addTo(map);

      // Draw the route polyline - Strava-style thick orange
      var polyline = L.polyline(route, {
        color: '#fc4c02',
        weight: 5,
        opacity: 1,
        lineJoin: 'round',
        lineCap: 'round',
      }).addTo(map);

      // Fit bounds to show entire route
      map.fitBounds(polyline.getBounds(), { padding: [30, 30] });

      // Directional arrow marker - points in direction of travel
      var arrowElement = null;
      var routeMarkerIcon = L.divIcon({
        className: 'route-marker',
        html: '<div class="route-marker-wrapper"><div class="route-arrow"></div></div>',
        iconSize: [12, 14],
        iconAnchor: [6, 7],
      });

      // Calculate bearing between two points (for arrow rotation)
      function getBearing(start, end) {
        var startLat = start[0] * Math.PI / 180;
        var startLng = start[1] * Math.PI / 180;
        var endLat = end[0] * Math.PI / 180;
        var endLng = end[1] * Math.PI / 180;
        var dLng = endLng - startLng;
        var x = Math.sin(dLng) * Math.cos(endLat);
        var y = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
        var bearing = Math.atan2(x, y) * 180 / Math.PI;
        return (bearing + 360) % 360;
      }

      // Photo slideshow function - polaroids scattered on desk
      function startSlideshow() {
        if (!photos.length || !slideshowElement) return;

        // Balanced arrangement - photos spread across entire card including center
        var arrangements = [
          { x: -85, y: -45, rotate: -7 },    // top left
          { x: 55, y: -40, rotate: 5 },      // top right
          { x: -25, y: 5, rotate: -3 },      // CENTER (hero position)
          { x: 75, y: 15, rotate: 6 },       // center right
          { x: -75, y: 45, rotate: 4 },      // bottom left
          { x: 45, y: 50, rotate: -5 },      // bottom right
          { x: 15, y: -50, rotate: 3 },      // top center
        ];

        // Track which photo is currently focused
        var focusedPhoto = null;
        var maxZIndex = 10;

        // Responsive photo sizes
        var isMobileDevice = window.innerWidth <= 900;
        var photoWidth = isMobileDevice ? 120 : 160;
        var photoHeight = isMobileDevice ? 90 : 120;
        var photoPadding = isMobileDevice ? '6px 6px 18px 6px' : '8px 8px 24px 8px';

        // Create sticker elements with inline styles
        var stickers = photos.map(function(url, index) {
          var pos = arrangements[index % arrangements.length];
          var sticker = document.createElement('div');
          // Polaroid style - starts hidden, z-index will be set when photo appears
          sticker.style.cssText = 'position:absolute; background:#fff; padding:' + photoPadding + '; box-shadow:0 8px 32px rgba(0,0,0,0.45), 0 2px 8px rgba(0,0,0,0.2); border-radius:3px; opacity:0; z-index:1; cursor:pointer; pointer-events:auto; transform:translate(' + pos.x + '%, ' + pos.y + '%) scale(0.8) rotate(' + pos.rotate + 'deg); transition:opacity 0.6s ease, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease;';

          var img = document.createElement('img');
          img.src = url;
          img.alt = 'Activity photo ' + (index + 1);
          img.style.cssText = 'display:block; width:' + photoWidth + 'px; height:' + photoHeight + 'px; object-fit:cover; border-radius:2px;';

          sticker.appendChild(img);
          slideshowElement.appendChild(sticker);
          return { el: sticker, pos: pos, index: index, originalZ: 1, isZoomed: false };
        });

        // Detect mobile for zoom scale adjustment
        var isMobile = window.innerWidth <= 900;
        var zoomScale = isMobile ? 1.8 : 2.4;

        // Click handler for focusing/unfocusing photos
        stickers.forEach(function(sticker) {
          sticker.el.addEventListener('click', function(e) {
            e.stopPropagation();

            if (sticker.isZoomed) {
              // Unfocus - return to original position
              sticker.el.style.transform = 'translate(' + sticker.pos.x + '%, ' + sticker.pos.y + '%) scale(1) rotate(' + sticker.pos.rotate + 'deg)';
              sticker.el.style.zIndex = sticker.originalZ;
              sticker.el.style.boxShadow = '0 8px 32px rgba(0,0,0,0.45), 0 2px 8px rgba(0,0,0,0.2)';
              sticker.isZoomed = false;
              focusedPhoto = null;
              // Remove overflow class from card
              if (routeCard) routeCard.classList.remove('photo-focused');
            } else {
              // Unfocus any previously focused photo
              if (focusedPhoto && focusedPhoto !== sticker) {
                focusedPhoto.el.style.transform = 'translate(' + focusedPhoto.pos.x + '%, ' + focusedPhoto.pos.y + '%) scale(1) rotate(' + focusedPhoto.pos.rotate + 'deg)';
                focusedPhoto.el.style.zIndex = focusedPhoto.originalZ;
                focusedPhoto.el.style.boxShadow = '0 8px 32px rgba(0,0,0,0.45), 0 2px 8px rgba(0,0,0,0.2)';
                focusedPhoto.isZoomed = false;
              }

              // Focus this photo - zoom in, straighten, bring to front
              maxZIndex++;
              sticker.el.style.transform = 'translate(-50%, -50%) scale(' + zoomScale + ') rotate(0deg)';
              sticker.el.style.zIndex = maxZIndex + 100;
              sticker.el.style.boxShadow = '0 20px 60px rgba(0,0,0,0.5), 0 8px 24px rgba(0,0,0,0.3)';
              sticker.isZoomed = true;
              focusedPhoto = sticker;
              // Add overflow class to card so photo isn't clipped
              if (routeCard) routeCard.classList.add('photo-focused');
            }
          });
        });

        var currentPhoto = 0;

        function showNextPhoto() {
          if (currentPhoto >= stickers.length) return;

          var sticker = stickers[currentPhoto];
          // Set z-index so later photos appear on top (like dropping on a desk)
          maxZIndex = 10 + currentPhoto;
          sticker.originalZ = maxZIndex;
          sticker.el.style.zIndex = maxZIndex;
          // Animate in and STAY - no fade out
          sticker.el.style.opacity = '1';
          sticker.el.style.transform = 'translate(' + sticker.pos.x + '%, ' + sticker.pos.y + '%) scale(1) rotate(' + sticker.pos.rotate + 'deg)';

          // Show next photo after delay
          currentPhoto++;
          if (currentPhoto < stickers.length) {
            setTimeout(showNextPhoto, 800);
          }
        }

        // Start showing photos after a brief pause
        setTimeout(showNextPhoto, 500);
      }

      // Function to start the route animation
      function startRouteAnimation() {
        // Trigger start time flash
        if (flashElement) {
          flashElement.classList.add('animate');
        }

        var marker = L.marker(route[0], { icon: routeMarkerIcon }).addTo(map);

        // Get the arrow element after marker is added to DOM
        setTimeout(function() {
          arrowElement = marker.getElement().querySelector('.route-arrow');
          if (arrowElement && route.length > 1) {
            var initialBearing = getBearing(route[0], route[1]);
            arrowElement.style.transform = 'rotate(' + initialBearing + 'deg)';
          }
        }, 10);

        var currentIndex = 0;
        var pointsPerStep = 3; // Skip some points for smoother perceived motion
        var animationSpeed = 100; // ms between updates (smoother with CSS transitions)

        function animateStep() {
          currentIndex += pointsPerStep;

          if (currentIndex >= route.length) {
            // Fade out and remove marker at the end
            var el = marker.getElement();
            if (el) {
              el.style.transition = 'opacity 0.5s ease';
              el.style.opacity = '0';
              setTimeout(function() { map.removeLayer(marker); }, 500);
            }
            return;
          }

          // Update position (CSS transition makes it smooth)
          marker.setLatLng(route[currentIndex]);

          // Rotate arrow to point in direction of travel
          if (arrowElement && currentIndex + pointsPerStep < route.length) {
            var bearing = getBearing(route[currentIndex], route[Math.min(currentIndex + pointsPerStep, route.length - 1)]);
            arrowElement.style.transform = 'rotate(' + bearing + 'deg)';
          }

          setTimeout(animateStep, animationSpeed);
        }

        // Start animation
        setTimeout(animateStep, animationSpeed);

        // Start photos after 2 seconds while marker continues
        setTimeout(startSlideshow, 2000);
      }

      // Use Intersection Observer to trigger animation when card comes into view
      var animationStarted = false;
      var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          if (entry.isIntersecting && !animationStarted) {
            animationStarted = true;
            // Small delay to let user see the map before animation starts
            setTimeout(startRouteAnimation, 300);
            observer.unobserve(routeCard);
          }
        });
      }, {
        threshold: 0.3 // Trigger when 30% of the card is visible
      });

      observer.observe(routeCard);
    });

    // Timeline scroll - auto-scroll with manual override
    var timelineSection = document.querySelector('.timeline-section');
    var scrollContainer = document.querySelector('.timeline-scroll-container');
    var timelineTrack = document.querySelector('.timeline-track');

    if (timelineSection && scrollContainer && timelineTrack) {
      var isVisible = false;
      var isUserInteracting = false;
      var autoScrollSpeed = 0.5; // pixels per frame (slow ambient scroll)
      var animationId = null;

      // Auto-scroll function
      function autoScroll() {
        if (!isVisible || isUserInteracting) {
          animationId = requestAnimationFrame(autoScroll);
          return;
        }

        scrollContainer.scrollLeft += autoScrollSpeed;

        // Infinite loop: when we've scrolled past halfway (duplicate content), reset
        var halfWidth = timelineTrack.scrollWidth / 2;
        if (scrollContainer.scrollLeft >= halfWidth) {
          scrollContainer.scrollLeft = 0;
        }

        animationId = requestAnimationFrame(autoScroll);
      }

      // Start auto-scroll loop
      animationId = requestAnimationFrame(autoScroll);

      // Intersection Observer - only auto-scroll when visible
      var timelineObserver = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          isVisible = entry.isIntersecting;
        });
      }, {
        threshold: 0.2
      });
      timelineObserver.observe(timelineSection);

      // Handle user interaction - pause auto-scroll
      function pauseAutoScroll() {
        isUserInteracting = true;
      }

      function resumeAutoScroll() {
        isUserInteracting = false;
      }

      // Mouse drag for desktop
      var isDragging = false;
      var startX = 0;
      var scrollStart = 0;

      scrollContainer.addEventListener('mousedown', function(e) {
        isDragging = true;
        startX = e.pageX - scrollContainer.offsetLeft;
        scrollStart = scrollContainer.scrollLeft;
        pauseAutoScroll();
      });

      scrollContainer.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        e.preventDefault();
        var x = e.pageX - scrollContainer.offsetLeft;
        var walk = (x - startX) * 1.5; // Scroll speed multiplier
        scrollContainer.scrollLeft = scrollStart - walk;
      });

      scrollContainer.addEventListener('mouseup', function() {
        isDragging = false;
        resumeAutoScroll();
      });

      scrollContainer.addEventListener('mouseleave', function() {
        if (isDragging) {
          isDragging = false;
          resumeAutoScroll();
        }
      });

      // Touch swipe for mobile
      var touchStartX = 0;
      var touchScrollStart = 0;

      scrollContainer.addEventListener('touchstart', function(e) {
        touchStartX = e.touches[0].pageX;
        touchScrollStart = scrollContainer.scrollLeft;
        pauseAutoScroll();
      }, { passive: true });

      scrollContainer.addEventListener('touchmove', function(e) {
        var x = e.touches[0].pageX;
        var walk = (touchStartX - x) * 1.2;
        scrollContainer.scrollLeft = touchScrollStart + walk;
      }, { passive: true });

      scrollContainer.addEventListener('touchend', function() {
        resumeAutoScroll();
      });

      // Handle infinite loop when user scrolls manually
      scrollContainer.addEventListener('scroll', function() {
        var halfWidth = timelineTrack.scrollWidth / 2;
        if (scrollContainer.scrollLeft >= halfWidth) {
          scrollContainer.scrollLeft = scrollContainer.scrollLeft - halfWidth;
        } else if (scrollContainer.scrollLeft <= 0 && !isDragging) {
          // If scrolled to start, could jump to end for reverse infinite scroll
          // But keeping it simple - just let it stay at start
        }
      });
    }
  });
</script>
